---
layout: post
title: 데이터의 흐름이해, 비동기 요청 처리
date: 2021-09-06 17:16:55 +0300
image: /assets/images/blog/post-5.jpg
author: hanna
tags: frontend
---

## Achievement Goals

- React 데이터 흐름을 알 수 있어야한다.
- 어떤 컴포넌트에 state가 위치하는지 알 수 있다.
- state 끌어오르기의 개념을 이해할 수 있다.
  상태 변경 함수가 정의 된 컴포넌트와 상태 변경 함수를 호출하는 컴포넌트가 다름을 알아야 한다.

# Effect Hook

- side effect가 어떤 의미인지 알 수 있다.
- React 컴포넌트를 만들 때 side effect로 부터 분리해서 생각할 수 있다.
- Effect hook 에서 dependency array 사용법을 이해할 수 있다.
- 컴포넌트 내에서 네트워크 요청시 로딩 화면과 같이 나은 ui 만드는 법을 이해할 수 있다.

## React 데이터 흐름

React의 개발 방식의 가장 큰 특징은 페이지 단위가 아닌, 컴포넌트 단위로 시작한다는 점이다.
프로토 타입에서 컴포넌트를 찾고 , 컴포넌트를 조립해 가면서 페이지를 만든다.
이는 상향식으로 만드는 방식이다. 그리고 상향식 방법은 테스트가 쉽고 확장성이 좋다는데 장점이 있다.

컴포넌트는 컴포넌트 바깥에서 props를 이용해 데이터를 마치 인자(arguments) 혹은 속성(attributes)처럼 전달받을 수 있다
즉, 데이터를 전달하는 주체는 부모 컴포넌트가 되며, 이는 데이터 흐름이 하향식이 됨을 의미한다.

단방향 데이터 흐름(one-way data flow)은 리액트를 설명하는 용어가 된다.

# 리액트에서 변하는 값과 변하지 않는 값

변하는 값 === props
변하지 않는 값 === state

모든 데이터는 상태 값으로 두지않고 상태를 최소화해야한다.
상태를 파악하는 질문을 확인해보고 상태 값인지를 구분 해야한다.

# 상태 (state)인지 확인하는 질문

1. 부모로부터 props를 통해 전달됩니까? 그러면 확실히 state가 아닙니다.
2. 시간이 지나도 변하지 않나요? 그러면 확실히 state가 아닙니다.
3. 컴포넌트 안의 다른 state나 props를 가지고 계산 가능한가요? 그렇다면 state가 아닙니다.

상태의 위치를 살펴볼 때 상태가 특정 컴포넌트에서만 유의미하다면, 특정 컴포넌트에만 두면 되니 어렵지 않지만, 만일 하나의 상태를 기반으로 두 컴포넌트가 영향을 받는다면 이 때에는 공통 소유 컴포넌트를 찾아 그 곳에 상태를 위치해야 한다.

즉, 두 개의 자식 컴포넌트가 하나의 상태에 접근하고자 할 때는 두 자식의 공통 부모 컴포넌트에 상태를 위치해야한다.

하지만 하위 컴포넌트에서 클릭 이벤트가 부모의 상태를 바꾸어야만 한다면 이는 state 끌어올리기 (Lifting state up)을 해주어야한다.

이는 상태를 변경시키는 함수 (handler)를 하위 컴포넌트에 props로 전달해서 해결할 수 있고, 이는 콜백 함수를 사용하는 방법과 비슷하다.

## State 끌어올리기 (Lifting State Up)

단방향 데이터 흐름이라는 원칙에 따라, 하위 컴포넌트는 상위 컴포넌트로 부터 전달받은 데이터의 형태 또는 타입이 무엇인지 알 수 있다. 하지만 어떤 위치에서 왔는지는 모르므로 하위 컴포넌트에서 어떤 이벤트로 인해 상위 컴포넌트의 상태가 바뀌는 것은 역방향 데이터 흐름이 될 수 있다. 이를 해결 하기 위해 REACT는 상위 컴포넌트의 상태를 변경하는 함수 / 그 자체를 하위 컴포넌트로 전달하고 이를 실행한다.
이는 단방향 데이터 흐름 원칙에 부합되는 해결 방안인데, 이를 상태 끌어올리기라 한다.

# Side Effect (부수 효과)

side effect는 함수 내에서 어떤 구현 함수가 외부에 영향을 끼치는 경우 해당함수는 side effect가 있다고 이야기 한다.

<pre>
<code>
// let foo = 'hello';

function bar() {
  foo = 'world';
}

bar(); // bar는 Side Effect를 발생시킵니다!
</code>
</pre>

# Pure Function (순수 함수)

순수 함수란, 오직 함수의 입력만이 함수의 결과에 영향을 주는 함수이다.
함수의 입력이 아닌 다른 값이 함수의 결과에 영향을 미치는 경우, 순수 함수라고 부를 수 없고 입력으로 전달된 값을 수정하지 않는다.

<pre>
<code>
function upper(str) {
  return str.toUpperCase(); // toUpperCase 메소드는 원본을 수정하지 않습니다 (Immutable)
}

upper('hello') // 'HELLO'
</code>
</pre>

# React의 함수 컴포넌트

앞서 배운 REACT의 함수 컴포넌트는 Props의 입력으로 JSX Element가 출력이 되어진다.
이는 어떤 side Effect도 없고 순수 함수로 작동된다.
하지만 보통 React 애플리케이션을 작성할 때는 AJAX 요청이 필요하거나, LocalStorage , 타이머와 같은 React와 상관없는 API를 사용하는 경우가 발생할 수 있다.
이 경우 리액트 입장에서는 side effect로 간주하며 React는 side effect를 다루기 위한 Hook인 Effect hook을 제공하게 된다.

## Effect hook

useEffect는 컴포넌트 내에서 Side effect를 실행할 수 있게 하는 Hook 입니다.

# API

예를 들어 컴포넌트에서 실행하는 Side effect는 브라우저 API를 이용하여, 타이틀을 변경하게 된다면 순서는

1. 컴포넌트 생성 후 처음 화면에 렌더링(표시)
2. 컴포넌트에 새로운 props가 전달되며 렌더링
3. 컴포넌트에 상태(state)가 바뀌며 렌더링

순서로 진행된다. 이와 같이 매 번 새롭게 컴포넌트가 렌더링될 때 Effect Hook이 실행되게 된다.

# Hook을 쓸 때 주의할 점

최상위에서만 Hook을 호출해야한다.
React 함수 내에서 Hook을 호출해야한다.

## Effect Hook (2) - 조건부 실행

## 조건부 effect 발생 (dependency array)

useEffect의 두 번째 인자는 배열이다.
이 배열은 조건을 담고 있고 조건은 boolean 형태의 표현식이 아닌, 어떤 값의 변경이 일어날 때를 의미한다면 해당 배열엔 어떤값의 목록이 들어가게 된다.

이 배열을 종속성 배열이라고 한다.

# API

useEffect의 두 번째 인자는 종속성 배열이다. 배열 내의 종속성1, 또는 종속성2의 값이 변할 때, 첫 번째 인자의 함수가 실행되게 된다.
배열 내의 어떤 값이 변할 때에만, (effect가 발생하는) 함수가 실행되는 원리이다.

# 단 한번만 실행되는 Effect 함수

만일 종속성 목록에 아무런 종속성도 없다면 아래와 같이 반응하게 된다.

1. 빈 배열 넣기
   useEffect(함수, [])

2. 아무것도 넣지 않기 (기본 형태)
   useEffect(함수)
